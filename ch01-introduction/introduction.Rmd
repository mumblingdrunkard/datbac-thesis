# Introduction

Operating systems are ingrained in daily life, running at the core of handheld devices such as phones and tablets, laptops and desktop computers, or even on top of other operating systems such as virtual machines on cloud servers.
The tiniest microcontrollers in a modern car are likely running some real-time operating system (\acrshort{rtos}).
It is practically impossible to live modern life without interacting with an operating system.
We use these systems without much thought, however.
Thanks to a series of clever abstractions, we think about the machine as a  tool for running applications and not a pile of copper and silicon.
We do not think about how the mouse and keyboard are polled a thousand times each second, nor do we worry about how our favourite word processor processes this input.
We use the devices.

Those skilled in _The Art of Computer Programming_ @taocp can usually be oblivious to the machine's inner workings.
The operating system has abstracted the hardware so that the average programmer doesn't worry about machine code, address translation, virtualisation, etc.
The programmer doesn't worry about how system calls are different from regular functions.
The system transparently handles the resulting trap exception.
A computer programmer does not have to be a computer engineer or architect.
They use the computer.

The implementation details of an operating system are not required knowledge for the vast majority of people.
That is perhaps a good thing as it is a moderately advanced topic and often requires intermediate knowledge of computer architecture.
However, we can take valuable knowledge from the design and implementation of operating systems and how they interact with other layers of the average computer.

Is it then possible to teach the concepts of operating systems with theory and practice _without_ teaching all of computer architecture and building from the ground up?
How early can this subject be introduced?

## What should I cover in the thesis? (TEMPORARY)

*Questions:*

- Why Go?
- Why emulation/simulation?
- Why a virtual CPU?
- Why RISC-V?
- Why 32 bit?
- Why caching?
- Why mmio?
- Why multicore?
- Why C?

*Background*

- nachos
  - TODO
- pintos
  - TODO
- xv6
  - "A modern reimplementation of Sixth Edition Unix in C for x86 and RISC-V systems."
    It has been used by multiple courses accross several universities to teach operating systems, e.g. at MIT where it was developed. @xv6
- minix
  - Originally a teaching operating system, but the third edition is focused on being a reliable microkernel.
    An accompanying book has been written for each of the three major versions.
    Often called _The MINIX Book_, it serves as the main documentation for its respective MINIX version.
      - _Operating Systems: Design and Implementation 1/e_. @ast1
      - _Operating Systems: Design and Implementation 2/e_. @ast2
      - _Operating Systems: Design and Implementation 3/e_. @ast3
    A (likely modified) version of MINIX is used in the Intel Management Engine that is embedded on all modern processors released by Intel. @ast-intel
- biscuitos
  - Was previously explored as an alternative for teaching operating systems in Go.
    It was found to be infeasible. @nielsen2019

*Advantages of the chosen approach*

- Go is higher level than C and generally easier to get started with
- Possible to run real code on top of the OS
- Can directly interact with _a_ processor and experiment with it
- Transparently view how programs interact with the OS
- Can modify the "hardware" to fit the different labs
  - TLB miss can be handled in software
  - Don't need to follow privileged spec when doing paging
  - Other memory virtualisation techniques can be used

*Disadvantages of the chosen approach*

- Not a "real" system
- User-mode applications will run at a fraction of the speed
- Data structures used by the kernel and data structures used by user-mode applications will be stored in different memory.
    - This is of course different from a "real" system where memory is shared between user-mode and kernel-mode processes
    - This can also be an advantage as it leads to less complexity for students learning about the subject

*About Go*

*About C*

*About RISC-V*

*What should the labs cover and why?*

1. *The process and the processor*
    - Short introduction to computer architecture
    - Assembly instructions
    - CPU traps
    - Memory
    - Memory mapping
    - Running a program on the CPU
    - A simple syscall on the CPU
1. *Scheduling*
    - Batch scheduling
    - Scheduling metrics
    - SJF scheduling (a form of batch scheduling)
    - Preemptive schedulers (SRJF, RR, Stride)
    - Modern schedulers (MLFQ, O(1), Brainfuck)
    - Scheduling interaction with caches.
1. *Memory virtualisation*
    - Base/bounds
    - Segmentation (base/bound extension)
    - Memory protection (read/write/exec flags, uncached?)
    - Paging
    - Interaction with caches (cache and TLB, invalidation, flushing, etc. etc..)
        - E.g. flushing parts of, or the entire TLB is required when updating the segment- or page-tables of a process.
            - (PRESSING): Is there a way to do this without locking on every TLB access?
            - Perhaps a channel of incoming invalidated ranges?
            - Atomic load?
              Like in the fetch-execute cycle where other threads can store a `Halting` state to the core to make it halt.
              This would instead load something like `Stale` instead and force the core to refresh its segment/paging TLB from common storage.
              Should the `Stale` variable perhaps be shared so that all cores can be forced to refresh in just a single store?
              This is potentially a big performance impact due to excessive TLB invalidation.
              Need a way to invalidate only parts of the TLB?
            - Look at `sync.Map`.
    - Questions:
        - Can segments be relocated?
            - If yes, how to handle updating the caches.
                - Should segment numbering be a combination of process ID and segment number?
                    E.g 24b process ID + 8b segment number.
                    The 24b process ID could be sent to a channel to invalidate the entire cached address space for that process.
                    This becomes very hard as the caches are physically indexed.
                    May need to tag it with the virtual address to recover the new address when flushing.
        - This is potentially a very large topic and should be covered in a separate lab.
1. *The process, revisited*
    - Reclaiming resources when a process ends
1. *C runtime?*
    - syscalls
        - fork/exec
        - read/write
        - brk/sbrk
    - allocators
        - malloc/free
1. *Concurrency*
    - Concurrency in Go
    - Demo: RISC-V mutex in C
    - Demo: RISC-V atomic operations
1. *(ADVANCED) Multicore scheduling*
    - Concurrent data structures for the kernel
    - Sharing queues
    - Core affinity
    - Cache interactions
1. *File system*
    - File descriptors
    - Buffers
    - Directories
    - Memory mapped files
    - The file system interface
1. *The process, revisited... again*
    - Reclaiming more resources when the process ends

*Framework implementation:*

- Structure
- Architecture
- Composition
- Implementation

*Reference implementation of lab assignments.*

```{r child='sec00-test.Rmd'}
```

```{r child='sec01-current-situation.Rmd'}
```
