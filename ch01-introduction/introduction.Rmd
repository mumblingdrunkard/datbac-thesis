# Introduction

Operating systems are ingrained in daily life, running at the core of handheld devices such as phones and tablets, in laptop and desktop computers, or even on top of other operating systems such as in virtual machines on cloud servers.
Even the tiniest microcontrollers in a modern car are likely running some kind of real time operating system (\acrshort{rtos}).
It is practically impossible to live modern life without interacting with an operating system.
We use these systems without much thought however.
Thanks to a series of clever abstractions we think about the machine as a useful tool for running applications and not a pile of copper and silicon through which electricity is passed.
We do not think about how the mouse and keyboard are polled a thousand times each second, nor do we worry about how this input is processed by our favorite word processor.
We just use the devices.

Even those skilled in _The Art of Computer Programming_ @taocp can usually be oblivious to the inner workings of the machine.
The operating system has abstracted the hardware in such a way that the average programmer doesn't worry about machine code, address translation, virtualisation, etc..
The programmer doesn't worry about how, when a system call is made, the \acrshort{cpu} executes a trap-instruction to escalate privileges and return control from user/application-mode to the underlying system.
A computer programmer does not have to be a computer engineer or architect.
They just use the computer.

Evidently, the implementation details of an operating system are not required knowledge for the vast majority of people.
This is perhaps a good thing as it is a moderately advanced topic and often requires intermediate knowledge of computer architecture.
However, there is valuable knowledge to be taken from the design and implementation of operating systems and how they interact with other layers of an average computer.

Is it then possible to teach the concepts of operating systems with theory and practice _without_ teaching all of computer architecture and _without_ building from the ground up? How early can this subject be introduced?

## What should I cover in the thesis? (TEMPORARY)

Questions:

- Why Go?
- Why emulation/simulation?
- Why a virtual CPU?
- Why RISC-V?
- Why 32 bit?
- Why caching?
- Why mmio?
- Why multicore?
- Why C?

Background

- nachos
- pintos
- xv6
- minix
- biscuitos

Advantages of the chosen methodology

- Go is higher level than C and generally easier to get started with
- Possible to run real code on top of the OS
- Can directly interact with _a_ processor and experiment with it
- Transparently view how programs interact with the OS

About Go

About C

About RISC-V

What should the labs cover and why?

1. The process
1. Scheduling
   - Batch scheduling
   - Scheduling metrics
   - SJF scheduling (a form of batch scheduling)
   - Preemptive schedulers (SRJF, RR, Stride)
   - Modern schedulers (MLFQ, O(1), Brainfuck)
1. Memory virtualisation
   - Base/bounds
   - Segmentation (base/bound extension)
   - Memory protection (read/write/exec flags, uncached?)
   - Paging
1. The process, revisited
   - Reclaiming resources when a process ends
1. C runtime?
   - syscalls
     - fork/exec
     - read/write
     - brk/sbrk
   - allocators
     - malloc/free
1. File system
   - File descriptors
   - Buffers
   - Directories
   - Memory mapped files
   - The file system interface
1. The process, revisited... again
   - Reclaiming more resources when the process ends

Framework implementation:

- Structure
- Architecture
- Composition
- Implementation

Reference implementation of lab assignments

```{r child='sec-current-situation.Rmd'}
```

```{r child='sec-evaluation-of-situation.Rmd'}
```
